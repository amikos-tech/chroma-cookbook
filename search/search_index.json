{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to ChromaDB Cookbook","text":"<p>This is a collection of ways to use, deploy, configure and troubleshoot ChromaDB. It is a result of experiences of supporting ChromaDB community over the past months.</p>"},{"location":"contributing/getting-started/","title":"Getting Started with Contributing to Chroma","text":""},{"location":"contributing/getting-started/#overview","title":"Overview","text":"<p>Here are some steps to follow:</p> <ul> <li>Fork the repository (if you are part of an organization to which you cannot grant permissions it might be advisable to fork under your own user account to allow other community members to contribute by granting them permissions, something that is a bit more difficult at organizational level)</li> <li>Clone your forked repo locally (git clone ...) under a dir with an apt name for the change you want to make e.g. <code>my_awesome_feature</code></li> <li>Create a branch for your change (git checkout -b my_awesome_feature)</li> <li>Make your changes</li> <li>Test (see Testing)</li> <li>Lint (see Linting)</li> <li>Commit your changes (git commit -am 'Added some feature')</li> <li>Push to the branch (git push origin my_awesome_feature)</li> <li>Create a new Pull Request (PR) from your forked repository to the main Chroma repository</li> </ul>"},{"location":"contributing/getting-started/#testing","title":"Testing","text":"<p>It is generally good to test your changes before submitting a PR.</p> <p>To run the full test suite:</p> <pre><code>pip install -r requirements_dev.txt\npytest\n</code></pre> <p>To run a specific test:</p> <pre><code>pytest chromadb/tests/test_api.py::test_get_collection\n</code></pre> <p>If you want to see the output of print statements in the tests, you can run:</p> <pre><code>pytest -s\n</code></pre> <p>If you want your pytest to stop on first failure, you can run:</p> <pre><code>pytest -x\n</code></pre>"},{"location":"contributing/getting-started/#integration-tests","title":"Integration Tests","text":"<p>You can only run the integration tests by running:</p> <pre><code>sh bin/bin/integration-test\n</code></pre> <p>The above will create a docker container and will run the integration tests against it. This will also include JS client.</p>"},{"location":"contributing/getting-started/#linting","title":"Linting","text":""},{"location":"contributing/useful-shortcuts/","title":"Useful Shortcuts for Contributors","text":""},{"location":"contributing/useful-shortcuts/#git","title":"Git","text":""},{"location":"contributing/useful-shortcuts/#aliases","title":"Aliases","text":""},{"location":"contributing/useful-shortcuts/#create-venv-and-install-dependencies","title":"Create venv and install dependencies","text":"<p>Add the following to your <code>.bashrc</code>, <code>.zshrc</code> or <code>.profile</code>:</p> <pre><code>alias chroma-init='python -m virtualenv venv &amp;&amp; source venv/bin/activate &amp;&amp; pip install -r requirements.txt &amp;&amp; pip install -r requirements_dev.txt'\n</code></pre>"},{"location":"core/clients/","title":"Chroma Clients","text":"<p>Clients TBD.</p>"},{"location":"core/collections/","title":"Collections","text":""},{"location":"core/collections/#collection-utilities","title":"Collection Utilities","text":""},{"location":"core/collections/#cloning-a-collection","title":"Cloning a collection","text":"<p>Here are some reasons why you might want to clone a collection:</p> <ul> <li>Change distance function (via metadata - <code>hnsw:space</code>)</li> <li>Change HNSW hyper parameters (<code>hnsw:M</code>, <code>hnsw:construction_ef</code>, <code>hnsw:search_ef</code>)</li> </ul> <pre><code>import chromadb\n\nclient = chromadb.PersistentClient(path=\"test\") # or HttpClient()\ncol = client.get_or_create_collection(\"test\") # create a new collection with L2 (default)\n\ncol.add(ids=[f\"{i}\" for i in range(1000)],documents=[f\"document {i}\" for i in range(1000)])\nnewCol = client.get_or_create_collection(\"test1\",metadata={\"hnsw:space\":\"cosine\"}) # let's change the distance function to cosine\n\nexisting_count = col.count()\nbatch_size = 10\nfor i in range(0,existing_count,batch_size):\n    batch = col.get(include = [\"metadatas\",\"documents\",\"embeddings\"], limit=batch_size, offset=i)\n    newCol.add(ids=batch[\"ids\"],documents=batch[\"documents\"],metadatas=batch[\"metadatas\"],embeddings=batch[\"embeddings\"])\n\nprint(newCol.count())\nprint(newCol.get(offset=0, limit=10)) #get first 10 documents\n</code></pre>"},{"location":"core/collections/#updating-documentrecord-metadata","title":"Updating Document/Record Metadata","text":"<p>In this example we loop through all documents of a collection and strip all metadata fields of leading and trailing whitespace. Change the <code>update_metadata</code> function to suit your needs.</p> <pre><code>from chromadb import Settings\nimport chromadb\n\nclient = chromadb.PersistentClient(path=\"test\", settings=Settings(allow_reset=True))\nclient.reset() #reset the database so we can run this script multiple times\ncol = client.get_or_create_collection(\"test\")\ncount= col.count()\n\n\ndef update_metadata(metadata: dict):\n    return {k: v.strip() for k, v in metadata.items()}\n\nfor i in range(0, count, 10):\n    batch = col.get(include = [\"metadatas\"], limit=10, offset=i)\n    col.update(ids=batch[\"ids\"], metadatas=[update_metadata(metadata) for metadata in batch[\"metadatas\"]])\n</code></pre>"},{"location":"core/concepts/","title":"Chroma Core Concepts","text":""},{"location":"core/concepts/#tenants","title":"Tenants","text":""},{"location":"core/concepts/#databases","title":"Databases","text":""},{"location":"core/concepts/#collections","title":"Collections","text":""},{"location":"core/concepts/#documents","title":"Documents","text":""},{"location":"core/concepts/#metadata","title":"Metadata","text":""},{"location":"core/document-ids/","title":"Document IDs","text":"<p>Chroma is unopinionated about document IDs and delegates those decisions to the user. This frees users to build semantics around their IDs.</p>"},{"location":"core/document-ids/#note-on-compound-ids","title":"Note on Compound IDs","text":"<p>While you can choose to use IDs that are composed of multiple sub-IDs (e.g. <code>user_id</code> + <code>document_id</code>), it is important to highlight that Chroma does not support querying by partial ID.</p>"},{"location":"core/document-ids/#common-practices","title":"Common Practices","text":""},{"location":"core/document-ids/#uuids","title":"UUIDs","text":"<p>UUIDs are a common choice for document IDs. They are unique, and can be generated in a distributed fashion. They are also opaque, which means that they do not contain any information about the document itself. This can be a good thing, as it allows you to change the document without changing the ID.</p> <pre><code>import uuid\nimport chromadb\n\nmy_documents = [\n    \"Hello, world!\",\n    \"Hello, Chroma!\"\n]\n\nclient = chromadb.Client()\n\ncollection.add(ids=[uuid.uuid4() for _ in range(len(documents))], documents=my_documents)\n</code></pre>"},{"location":"core/document-ids/#hashes","title":"Hashes","text":"<p>Hashes are another common choice for document IDs. They are unique, and can be generated in a distributed fashion. They are also opaque, which means that they do not contain any information about the document itself. This can be a good thing, as it allows you to change the document without changing the ID.</p> <pre><code>import hashlib\nimport os\nimport chromadb\n\ndef generate_sha256_hash():\n    # Generate a random number\n    random_data = os.urandom(16)\n    # Create a SHA256 hash object\n    sha256_hash = hashlib.sha256()\n    # Update the hash object with the random data\n    sha256_hash.update(random_data)\n    # Return the hexadecimal representation of the hash\n    return sha256_hash.hexdigest()\n\n\nmy_documents = [\n    \"Hello, world!\",\n    \"Hello, Chroma!\"\n]\n\nclient = chromadb.Client()\n\ncollection.add(ids=[generate_sha256_hash() for _ in range(len(documents))], documents=my_documents)\n</code></pre> <p>It is also possible to use the document as basis for the hash, the downside of that is that when the document changes and you have a semantic around the text as relating to the hash, you may need to update the hash.</p> <pre><code>import hashlib\nimport chromadb\n\ndef generate_sha256_hash_from_text(text):\n    # Create a SHA256 hash object\n    sha256_hash = hashlib.sha256()\n    # Update the hash object with the text encoded to bytes\n    sha256_hash.update(text.encode('utf-8'))\n    # Return the hexadecimal representation of the hash\n    return sha256_hash.hexdigest()\nmy_documents = [\n    \"Hello, world!\",\n    \"Hello, Chroma!\"\n]\n\nclient = chromadb.Client()\n\ncollection.add(ids=[generate_sha256_hash_from_text(documents[i]) for i in range(len(documents))], documents=my_documents)\n</code></pre>"},{"location":"core/document-ids/#semantic-strategies","title":"Semantic Strategies","text":"<p>In this section we'll explore a few different use cases for building semantics around document IDs.</p> <ul> <li>URL Slugs - if your docs are web pages with permalinks (e.g. blog posts), you can use the URL slug as the document ID.</li> <li>File Paths - if your docs are files on disk, you can use the file path as the document ID.</li> </ul>"},{"location":"core/system_constraints/","title":"Chroma System Constraints","text":"<p>This section contains common constraints of Chroma.</p> <ul> <li>Chroma is thread-safe</li> <li>Chroma is not process-safe</li> <li>Multiple Chroma Clients (Ephemeral, Persistent, Http) can be created from one or more threads within the same process</li> <li>A collection's name is unique within a Tenant and DB</li> <li>A collection's dimensions cannot change after creation =&gt; you cannot change the embedding function after creation</li> <li>Chroma operates in two modes - standalone and client/server</li> </ul>"},{"location":"core/system_constraints/#operational-modes","title":"Operational Modes","text":"<p>Chroma can be operated in two modes:</p> <ul> <li>Standalone - This allows embedding Chroma in your python application without the need to communicate with external processes.</li> <li>Client/Server - This allows embedding Chroma in your python application as a thin-client with minimal dependencies and communicating with it via REST API. This is useful when you want to use Chroma from multiple processes or even multiple machines.</li> </ul> <p>Depending on the mode you choose, you will need to consider the following component responsibilities:</p> <ul> <li>Standalone:</li> <li>Clients (Persistent, Ephemeral) - Responsible for persistence, embedding, querying</li> <li>Client/Server:</li> <li>Clients (HttpClient) - Responsible for embedding, communication with Chroma server via REST API</li> <li>Server - Responsible for persistence and querying</li> </ul> <p></p>"},{"location":"embeddings/bring-your-own-embeddings/","title":"Creating your own embedding function","text":"<pre><code>from chromadb.api.types import (\n    Documents,\n    EmbeddingFunction,\n    Embeddings\n)\n\nclass MyCustomEmbeddingFunction(EmbeddingFunction[Documents]):\n    def __init__(\n        self,\n        my_ef_param: str\n    ):\n        \"\"\"Initialize the embedding function.\"\"\"\n\n    def __call__(self, input: Documents) -&gt; Embeddings:\n        \"\"\"Embed the input documents.\"\"\"\n        return self._my_ef(input)\n</code></pre> <p>Now let's break the above down.</p> <p>First you create a class that inherits from <code>EmbeddingFunction[Documents]</code>. The <code>Documents</code> type is a list of <code>Document</code> objects. Each <code>Document</code> object has a <code>text</code> attribute that contains the text of the document. Chroma also supports multi-modal</p>"},{"location":"embeddings/gpu-support/","title":"Embedding Functions GPU Support","text":"<p>By default Chroma does not require GPU support for embedding functions. However, if you want to use GPU support, some of the functions, especially those running locally provide GPU support.</p>"},{"location":"embeddings/gpu-support/#sentence-transformers","title":"Sentence Transformers","text":"<pre><code>import time\nfrom chromadb.utils.embedding_functions import SentenceTransformerEmbeddingFunction\n# This will download the model to your local machine and set it up for GPU support\nef = SentenceTransformerEmbeddingFunction(model_name=\"thenlper/gte-small\", device=\"cuda\")\n\n# Test with 10k documents\ndocs = []\nfor i in range(10000):\n  docs.append(f\"this is a document with id {i}123132\")\n\nstart_time = time.time()\nembeddings = ef(docs)\nend_time = time.time()\nprint(f\"Elapsed time: {end_time - start_time} seconds\")\n</code></pre> <p>Note: You can run the above example in google Colab - see the notebook</p>"},{"location":"integrations/langchain/embeddings/","title":"Langchain Embeddings","text":""},{"location":"integrations/langchain/embeddings/#embedding-functions","title":"Embedding Functions","text":"<p>Chroma and Langchain both offer embedding functions which are wrappers on top of popular embedding models.</p> <p>Unfortunately Chroma and LC's embedding functions are not compatible with each other. Below we offer two adapters to convert Chroma's embedding functions to LC's and vice versa.</p> <p>Here is the adapter to convert Chroma's embedding functions to LC's:</p> <pre><code>from langchain_core.embeddings import Embeddings\nfrom chromadb.api.types import EmbeddingFunction\n\nclass ChromaEmbeddingsAdapter(Embeddings):\n  def __init__(self,ef:EmbeddingFunction):\n    self.ef = ef\n\n  def embed_documents(self,texts):\n    return self.ef(texts)\n\n  def embed_query(self, query):\n    return self.ef([query])[0]\n\n</code></pre> <p>Here is the adapter to convert LC's embedding functions to Chroma's:</p> <pre><code>from langchain_core.embeddings import Embeddings\nfrom chromadb.api.types import EmbeddingFunction\n\nclass LangChainEmbeddingAdapter(EmbeddingFunction):\n  def __init__(self,ef:Embeddings):\n    self.ef = ef\n\n  def __call__(self, input: Documents) -&gt; Embeddings:\n    # LC EFs also have embed_query but Chroma doesn't support that so we just use embed_documents\n    # TODO: better type checking\n    return self.ef.embed_documents(input)\n\n</code></pre>"},{"location":"integrations/langchain/retrievers/","title":"\ud83e\udd9c\u26d3\ufe0f Langchain Retriever","text":"<p>TBD: describe what retrievers are in LC and how they work.</p>"},{"location":"integrations/langchain/retrievers/#vector-store-retriever","title":"Vector Store Retriever","text":"<p>In the below example we demonstrate how to use Chroma as a vector store retriever with a filter query.</p> <p>Note that the filter is supplied whenever we create the retriever object so the filter applies to all queries (<code>get_relevant_documents</code>).</p> <pre><code>from langchain.document_loaders import OnlinePDFLoader\nfrom langchain.chains import RetrievalQA\nfrom langchain.llms import OpenAI\nfrom langchain.vectorstores import Chroma\nfrom typing import Dict, Any\nimport chromadb\nfrom langchain_core.embeddings import Embeddings\n\nclient = chromadb.PersistentClient(path=\"./chroma\")\n\ncol = client.get_or_create_collection(\"test\")\n\ncol.upsert([f\"{i}\" for i in range(10)],documents=[f\"This is document #{i}\" for i in range(10)],metadatas=[{\"id\":f\"{i}\"} for i in range(10)])\n\nef = chromadb.utils.embedding_functions.DefaultEmbeddingFunction()\n\nclass DefChromaEF(Embeddings):\n  def __init__(self,ef):\n    self.ef = ef\n\n  def embed_documents(self,texts):\n    return self.ef(texts)\n\n  def embed_query(self, query):\n    return self.ef([query])[0]\n\n\ndb = Chroma(client=client, collection_name=\"test\",embedding_function=DefChromaEF(ef))\n\nretriever = db.as_retriever(search_kwargs={\"filter\":{\"id\":\"1\"}})\n\ndocs = retriever.get_relevant_documents(\"document\")\n\nassert len(docs)==1\n</code></pre> <p>Ref: https://colab.research.google.com/drive/1L0RwQVVBtvTTd6Le523P4uzz3m3fm0pH#scrollTo=xROOfxLohE5j</p>"},{"location":"integrations/llamaindex/embeddings/","title":"LlamaIndex Embeddings","text":""},{"location":"integrations/llamaindex/embeddings/#embedding-functions","title":"Embedding Functions","text":"<p>Chroma and LlamaIndex both offer embedding functions which are wrappers on top of popular embedding models.</p> <p>Unfortunately Chroma and LI's embedding functions are not compatible with each other. Below we offer an adapters to convert LI embedding function to Chroma one.</p> <pre><code>from llama_index.embeddings.base import BaseEmbedding\nfrom chromadb.api.types import EmbeddingFunction\n\nclass LlamaIndexEmbeddingAdapter(EmbeddingFunction):\n  def __init__(self,ef:BaseEmbedding):\n    self.ef = ef\n\n  def __call__(self, input: Documents) -&gt; Embeddings:\n    return [node.embedding for node in self.ef(input)]\n\n</code></pre> <p>An example of how to use the above with LlamaIndex:</p> <p>Note: Make sure you have <code>OPENAI_API_KEY</code> as env var.</p> <pre><code>from llama_index.embeddings import OpenAIEmbedding\nfrom llama_index import ServiceContext, set_global_service_context\nimport chromadb\n\nembed_model = OpenAIEmbedding(embed_batch_size=10)\n\nclient = chromadb.Client()\n\ncol = client.get_or_create_collection(\"test_collection\",embedding_function=LlamaIndexEmbeddingAdapter(embed_model))\n\ncol.add(ids=[\"1\"],documents=[\"this is a test document\"])\n# your embeddings should be of 1536 dimensions (OpenAI's ADA model)\n</code></pre>"},{"location":"running/running-chroma/","title":"Running Chroma","text":""},{"location":"running/running-chroma/#cli","title":"CLI","text":"<pre><code>pip install chromadb\nchroma run --path /path/to/my/localdata\n</code></pre> <p>Available options:</p> Option Description <code>--path</code> Path to the collection. <code>--host</code> Host to run the server on. <code>--port</code> Port to run the server on."},{"location":"running/running-chroma/#docker-run","title":"Docker Run","text":"<p>The below command will run a background container of chroma named <code>chroma</code> with the data stored in <code>./chroma-data</code> (mounted volume) and exposed on port <code>8000</code>. The <code>-e</code> env var <code>IS_PERSISTENT=true</code> will ensure that the data is persisted in the mounted volume.</p> <pre><code>docker run -d --rm --name chroma -v ./chroma-data:/chroma/chroma -p 8000:8000 -e IS_PERSISTENT=true chromadb/chroma:latest\n</code></pre>"},{"location":"running/running-chroma/#docker-compose-cloned-repo","title":"Docker Compose (cloned repo)","text":"<pre><code>git clone \ndocker-compose up -d --build\n</code></pre>"},{"location":"running/running-chroma/#docker-compose-cloned-repo-with-overrides","title":"Docker Compose (cloned repo with overrides)","text":"<p>Create an override file <code>docker-compose.override.yml</code>. The override file can be used to override any of the settings in Chroma's default <code>docker-compose.yml</code> file.</p> <p>Here is an example where we override the exposed port to be <code>8001</code> instead of <code>8000</code> (the default):</p> <pre><code>version: '3.9'\nservices:\n  server:\n    ports:\n      - 8001:8000\n</code></pre> <p>Here is another example where we mount a local directory (<code>./chroma-data</code>) to the container's <code>/chroma/chroma</code> directory:</p> <pre><code>version: '3.9'\nservices:\n  server:\n    volumes:\n      - ./chroma-data:/chroma/chroma\n</code></pre> <p>Generally <code>.override.</code> files are stored together with the main docker-compose file however you can store them anywhere and use the <code>-f</code> flag to specify the override file:</p> <pre><code>docker-compose -f docker-compose.yml -f docker-compose.override.yml up -d --build\n</code></pre> <p>Note: The order of the <code>-f</code> flags is important. The first file specified is the base file and the second file specified is the override file. Note: When destroying the stack you must specify the override file as well - <code>docker-compose -f docker-compose.yml -f docker-compose.override.yml down --rmi --volumes</code></p> <pre><code>\n## Docker Compose (pulled image)\n\n```yaml\n</code></pre>"},{"location":"strategies/keyword-search/","title":"Keyword Search","text":"<p>Chroma uses SQLite for storing metadata and documents. Additionally documents are indexed using SQLite FTS5 for fast text search.</p> <pre><code>import chromadb\nfrom chromadb.config import Settings\n\nclient = chromadb.PersistentClient(path=\"test\", settings=Settings(allow_reset=True))\n\nclient.reset()\ncol = client.get_or_create_collection(\"test\")\n\ncol.upsert(ids=[\"1\", \"2\", \"3\"], documents=[\"He is a technology freak and he loves AI topics\", \"AI technology are advancing at a fast pace\", \"Innovation in LLMs is a hot topic\"],metadatas=[{\"author\": \"John Doe\"}, {\"author\": \"Jane Doe\"}, {\"author\": \"John Doe\"}])\ncol.query(query_texts=[\"technology\"], where_document={\"$or\":[{\"$contains\":\"technology\"}, {\"$contains\":\"freak\"}]})\n</code></pre> <p>The above should return:</p> <pre><code>{'ids': [['2', '1']],\n 'distances': [[1.052205477809135, 1.3074231535113972]],\n 'metadatas': [[{'author': 'Jane Doe'}, {'author': 'John Doe'}]],\n 'embeddings': None,\n 'documents': [['AI technology are advancing at a fast pace',\n   'He is a technology freak and he loves AI topics']],\n 'uris': None,\n 'data': None}\n</code></pre>"},{"location":"strategies/privacy/","title":"Privacy Strategies","text":""},{"location":"strategies/privacy/#overview","title":"Overview","text":"<p>TBD</p>"},{"location":"strategies/privacy/#encryption","title":"Encryption","text":""},{"location":"strategies/privacy/#document-encryption","title":"Document Encryption","text":""},{"location":"strategies/privacy/#client-side-document-encryption","title":"Client-side Document Encryption","text":"<p>See the notebook on client-side document encryption.</p>"},{"location":"strategies/time-based-queries/","title":"Time-based Queries","text":""},{"location":"strategies/time-based-queries/#filtering-documents-by-timestamps","title":"Filtering Documents By Timestamps","text":"<p>In the example below, we create a collection with 100 documents, each with a random timestamp in the last two weeks. We then query the collection for documents that were created in the last week.</p> <p>The example demonstrates how Chroma metadata can be leveraged to filter documents based on how recently they were added or updated.</p> <pre><code>import uuid\nimport chromadb\n\nimport datetime\nimport random\n\nnow = datetime.datetime.now()\ntwo_weeks_ago = now - datetime.timedelta(days=14)\n\ndates = [\n    two_weeks_ago + datetime.timedelta(days=random.randint(0, 14))\n    for _ in range(100)\n]\ndates = [int(date.timestamp()) for date in dates]\n\n# convert epoch seconds to iso format\n\ndef iso_date(epoch_seconds): return datetime.datetime.fromtimestamp(\n    epoch_seconds).isoformat()\n\nclient = chromadb.EphemeralClient()\n\ncol = client.get_or_create_collection(\"test\")\n\ncol.add(ids=[f\"{uuid.uuid4()}\" for _ in range(100)], documents=[\n    f\"document {i}\" for i in range(100)], metadatas=[{\"date\": date} for date in dates])\n\nres = col.get(where={\"date\": {\"$gt\": (now - datetime.timedelta(days=7)).timestamp()}})\n\nfor i in res['metadatas']:\n    print(iso_date(i['date']))\n</code></pre> <p>Ref: https://gist.github.com/tazarov/3c9301d22ab863dca0b6fb1e5e3511b1</p>"}]}